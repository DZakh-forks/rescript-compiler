#!/usr/bin/env node
//@ts-check
"use strict";

/* This script is supposed to be running in project root directory
 * It matters since we need read .sourcedirs(location)
 * and its content are file/directories with regard to project root
 */

/**
 * @typedef {Object} WatchCtx
 * @property {string} projectPath - The path to the project root.
 * @property {string} genTypeFileExtension - The genType file extention to ignore generated file changes in watcher.
 * @property {{ [dir: string]: fs.FSWatcher }} dirWatchers - Dict of project dir watchers (mutable).
 * @property {boolean} isBsConfigDirty - Responsible for syncing dirWatchers on bsconfig change (mutable).
 * @property {boolean} isRebuildPending - Allow only one rebuild at a time (mutable).
 * @property {boolean} isReRebuildNeeded - In case there was a change when compiler was running (mutable).
 * @property {NodeJS.Timeout | undefined} rebuildTimeout - Timeout to debounce planned rebuilds (mutable).
 */

/**
 * @typedef {Object} ProjectFiles
 * @property {Set<string>} dirsSet
 * @property {Set<string>} generatedFilesSet
 */

var child_process = require("child_process");
var os = require("os");
var path = require("path");
var fs = require("fs");
var bsc_exe = require("./scripts/bin_path").bsc_exe;
var rescript_exe = require("./scripts/bin_path").rescript_exe;

var LAST_SUCCESS_BUILD_STAMP = 0;
var cwd = process.cwd();
var lockFileName = path.join(cwd, ".bsb.lock");
process.env.BSB_PROJECT_ROOT = cwd;

const isTtyError = process.stderr.isTTY;
const isTtyStd = process.stdout.isTTY;

let verbose = false;

/**
 * @time{[number,number]}
 */
let startTime;
function updateStartTime() {
  startTime = process.hrtime();
}
function updateFinishTime() {
  const diff = process.hrtime(startTime);
  return diff[0] * 1e9 + diff[1];
}

/**
 * @param {string} projectPath
 * @return {ProjectFiles}
 */
function getProjectFiles(projectPath) {
  const sourcedirsPath = path.join(
    projectPath,
    "lib",
    "bs",
    ".sourcedirs.json"
  );
  if (fs.existsSync(sourcedirsPath)) {
    const sourcedirs = JSON.parse(fs.readFileSync(sourcedirsPath, "utf8"));
    return {
      dirsSet: new Set(sourcedirs.dirs),
      generatedFilesSet: new Set(sourcedirs.generated),
    };
  } else {
    return {
      dirsSet: new Set(),
      generatedFilesSet: new Set(),
    };
  }
}

/**
 *
 * @param {string} str
 */
function dlog(str) {
  if (verbose) {
    console.log(str);
  }
}

var process_argv = process.argv;

if (process.env.NINJA_ANSI_FORCED === undefined) {
  if (require("tty").isatty(1)) {
    process.env.NINJA_ANSI_FORCED = "1";
  }
} else {
  dlog(`NINJA_ANSI_FORCED: "${process.env.NINJA_ANSI_FORCED}"`);
}
function help() {
  console.log(`Usage: rescript <options> <subcommand>

\`rescript\` is equivalent to \`rescript build\`

Options:
  -v, -version  display version number
  -h, -help     display help

Subcommands:
  build
  clean
  format
  convert
  dump
  help

Run \`rescript <subcommand> -h\` for subcommand help. Examples:
  rescript build -h
  rescript format -h
The default \`rescript\` is equivalent to \`rescript build\` subcommand  
`);
}

var isBuildLocked = false;
function releaseBuild() {
  if (isBuildLocked) {
    try {
      fs.unlinkSync(lockFileName);
    } catch (err) {
      if (verbose) {
        console.error("Failed releasing build", err);
      }
    }
    isBuildLocked = false;
  }
}

// We use [~perm:0o664] rather than our usual default perms, [0o666], because
// lock files shouldn't rely on the umask to disallow tampering by other.
function acquireBuild() {
  if (isBuildLocked) {
    return false;
  } else {
    try {
      const fid = fs.openSync(lockFileName, "wx", 0o664);
      fs.closeSync(fid);
      isBuildLocked = true;
    } catch (err) {
      if (err.code === "EEXIST") {
        console.warn(lockFileName, "already exists, try later");
      } else console.log(err);
    }
    return isBuildLocked;
  }
}

function onUncaughtException(err) {
  console.error("Uncaught Exception", err);
  releaseBuild();
  process.exit(1);
}

function exitProcess() {
  releaseBuild();
  process.exit(0);
}

/**
 * @param {number} [code]
 */
function logFinishCompiling(code) {
  let log = `>>>> Finish compiling`;
  if (code) {
    log = log + " (exit: " + code + ")";
  }
  if (isTtyStd) {
    log = "\x1b[36m" + log + "\x1b[0m";
  }
  if (code) {
    console.log(log);
  } else {
    console.log(log, Math.floor(updateFinishTime() / 1e6), "mseconds");
  }
}

function logStartCompiling() {
  updateStartTime();
  let log = `>>>> Start compiling`;
  if (isTtyStd) {
    log = "\x1b[36m" + log + "\x1b[0m";
  }
  console.log(log);
}

/**
 * @param {Array<string>} args
 * @param {() => void} [maybeOnSuccess]
 */
function delegateCommand(args, maybeOnSuccess) {
  /**
   * @type {child_process.ChildProcess}
   */
  var p;
  if (acquireBuild()) {
    try {
      p = child_process.spawn(rescript_exe, args, {
        stdio: "inherit",
      });
    } catch (e) {
      if (e.code === "ENOENT") {
        // when bsb is actually not found
        console.error(String(e));
      }
      releaseBuild();
      process.exit(2);
    }
    // The 'close' event will always emit after 'exit' was already emitted, or
    // 'error' if the child failed to spawn.
    p.on("close", code => {
      releaseBuild();
      if (maybeOnSuccess && !code) {
        maybeOnSuccess();
        return;
      }
      process.exit(code || 0);
    });
  } else {
    console.warn(`Another build detected or stale lockfile ${lockFileName}`);
    // rasing magic code
    process.exit(133);
  }
}

process.on("uncaughtException", onUncaughtException);

// OS signal handlers
// Ctrl+C
process.on("SIGINT", exitProcess);
// kill pid
process.on("SIGUSR1", exitProcess);
process.on("SIGUSR2", exitProcess);
process.on("SIGTERM", exitProcess);
process.on("SIGHUP", exitProcess);

const maybeSubcommand = process_argv[2];

if (maybeSubcommand === "build" && process_argv.includes("-w")) {
  // All clients of type MiniWebSocket
  /**
   * @type {any[]}
   */
  let wsClients = [];
  let withWebSocket = false;
  let webSocketHost = "localhost";
  let webSocketPort = 9999;

  let LAST_BUILD_START = 0;

  const delegatedArgs = process_argv.slice(2);
  verbose = delegatedArgs.includes("-verbose");

  var wsParamIndex = delegatedArgs.indexOf("-ws");
  if (wsParamIndex > -1) {
    var hostAndPortNumber = (delegatedArgs[wsParamIndex + 1] || "").split(":");
    /**
     * @type {number}
     */
    var portNumber;
    if (hostAndPortNumber.length === 1) {
      portNumber = parseInt(hostAndPortNumber[0]);
    } else {
      webSocketHost = hostAndPortNumber[0];
      portNumber = parseInt(hostAndPortNumber[1]);
    }
    if (!isNaN(portNumber)) {
      webSocketPort = portNumber;
    }
    withWebSocket = true;
    dlog(`WebSocket host & port number: ${webSocketHost}:${webSocketPort}`);
  }

  const rescriptWatchBuildArgs = verbose
    ? ["build", "-no-deps", "-verbose"]
    : ["build", "-no-deps"];

  function notifyClients() {
    wsClients = wsClients.filter(x => !x.closed && !x.socket.destroyed);
    var wsClientsLen = wsClients.length;
    dlog(`Alive sockets number: ${wsClientsLen}`);
    var data = '{"LAST_SUCCESS_BUILD_STAMP":' + LAST_SUCCESS_BUILD_STAMP + "}";
    for (var i = 0; i < wsClientsLen; ++i) {
      // in reverse order, the last pushed get notified earlier
      var client = wsClients[wsClientsLen - i - 1];
      if (!client.closed) {
        client.sendText(data);
      }
    }
  }

  function setUpWebSocket() {
    var WebSocket = require("./lib/minisocket.js").MiniWebSocket;
    var id = setInterval(notifyClients, 3000);
    require("http")
      .createServer()
      .on("upgrade", function (req, socket, upgradeHead) {
        dlog("connection opened");
        var ws = new WebSocket(req, socket, upgradeHead);
        socket.on("error", function (err) {
          dlog(`Socket Error ${err}`);
        });
        wsClients.push(ws);
      })
      .on("error", function (err) {
        // @ts-ignore
        if (err !== undefined && err.code === "EADDRINUSE") {
          var error = isTtyStd ? `\x1b[1;31mERROR:\x1b[0m` : `ERROR:`;
          console.error(`${error} The websocket port number ${webSocketPort} is in use.
Please pick a different one using the \`-ws [host:]port\` flag from bsb.`);
        } else {
          console.error(err);
        }
        process.exit(2);
      })
      .listen(webSocketPort, webSocketHost);
  }

  /**
   * @param {WatchCtx} watchCtx
   * @param {string | null} fileName
   * @param {ProjectFiles} projectFiles
   */
  function checkIsRebuildReason(watchCtx, fileName, projectFiles) {
    // Return true if filename is nil, filename is only provided on Linux, macOS, Windows, and AIX.
    // On other systems, we just have to assume that any change is valid.
    // This could cause problems if source builds (generating js files in the same directory) are supported.
    if (!fileName) return true;

    return !(
      fileName === ".merlin" ||
      fileName.endsWith(".js") ||
      fileName.endsWith(".mjs") ||
      fileName.endsWith(".cjs") ||
      fileName.endsWith(watchCtx.genTypeFileExtension) ||
      projectFiles.generatedFilesSet.has(fileName) ||
      fileName.endsWith(".swp")
    );
  }

  /**
   * TODO: how to make it captured by vscode
   * @param error {string}
   * @param highlight {string}
   */
  function outputError(error, highlight) {
    if (isTtyError && highlight) {
      process.stderr.write(
        error.replace(highlight, "\x1b[1;31m" + highlight + "\x1b[0m")
      );
    } else {
      process.stderr.write(error);
    }
  }

  // Note this function filters the error output
  // it relies on the fact that ninja will merege stdout and stderr
  // of the compiler output, if it does not
  // then we should have a way to not filter the compiler output
  /**
   * @param {WatchCtx} watchCtx
   * @param [number] retry
   */
  function rebuild(watchCtx, retry = 0) {
    watchCtx.isRebuildPending = true;
    if (acquireBuild()) {
      LAST_BUILD_START = Date.now();
      if (process.env.BS_WATCH_CLEAR && console.clear) {
        console.clear();
      }
      logStartCompiling();
      child_process
        .spawn(rescript_exe, rescriptWatchBuildArgs, {
          stdio: ["inherit", "inherit", "pipe"],
        })
        .on("data", s => {
          outputError(s, "ninja: error");
        })
        .on("exit", _code => {
          // Can be null when exited via signal. Not our case, so treat it as an error
          const code = _code === null ? 1 : _code;
          releaseBuild();
          logFinishCompiling(code);
          if (code === 0) {
            LAST_SUCCESS_BUILD_STAMP = Date.now();
            notifyClients();
          }
          // Run it on rebuild complete, since we need to updated sourcedirs.json file
          if (watchCtx.isBsConfigDirty) {
            syncDirsWatchers(watchCtx);
          }
          if (watchCtx.isReRebuildNeeded) {
            watchCtx.isReRebuildNeeded = false;
            rebuild(watchCtx);
          } else {
            watchCtx.isRebuildPending = false;
          }
        })
        .stderr.setEncoding("utf8");
    } else if (retry === 5) {
      console.error(`Failed to rebuild the project. Can't acquire ".bsb.lock"`);
      process.exit(2);
    }
    // if acquiring lock failed, we try to retry in case of a multiple-process
    // also, it could fail due to other issues like .bsb.lock
    else {
      const waitTime = Math.pow(2, retry) * 40;
      dlog(`Couldn't acquire ".bsb.lock". Retry in ${waitTime}ms`);
      setTimeout(() => {
        rebuild(watchCtx, retry + 1);
      }, waitTime);
    }
  }

  /**
   * @param {WatchCtx} watchCtx
   * @param {string} reason
   */
  function planRebuild(watchCtx, reason) {
    const timeFromLastBuild = Date.now() - LAST_BUILD_START;
    dlog(
      `Rebuild planned by ${reason}. Time from last build: ${timeFromLastBuild}ms`
    );
    if (timeFromLastBuild < 5) {
      dlog("Rebuild canceled because of little time from the last build");
      // for 5ms, we could think that the ninja not get
      // kicked yet, so there is really no need
      // to send more events here
      return;
    }
    if (watchCtx.isRebuildPending) {
      dlog("Rebuild scheduled after the existing pending rebuild");
      watchCtx.isReRebuildNeeded = true;
      return;
    }

    // Some editors are using temporary files to store edits.
    // This results in two sync change events: change + rename and two sync builds.
    // Debounce rebuild to ensure that only one build done.
    if (watchCtx.rebuildTimeout) {
      clearTimeout(watchCtx.rebuildTimeout);
    }
    watchCtx.rebuildTimeout = setTimeout(() => {
      watchCtx.rebuildTimeout = undefined;
      rebuild(watchCtx);
    });
  }

  /**
   * @param {WatchCtx} watchCtx
   */
  function syncDirsWatchers(watchCtx) {
    const projectFiles = getProjectFiles(watchCtx.projectPath);

    for (const dir in watchCtx.dirWatchers) {
      if (!projectFiles.dirsSet.has(dir)) {
        const watcher = watchCtx.dirWatchers[dir];
        delete watchCtx.dirWatchers[dir];
        watcher.close();
        dlog(`Removed watcher for the "${dir}" dir`);
      }
    }

    for (const dir of projectFiles.dirsSet) {
      if (!watchCtx.dirWatchers[dir]) {
        const watcher = fs.watch(dir, (event, reason) => {
          if (checkIsRebuildReason(watchCtx, reason, projectFiles)) {
            planRebuild(watchCtx, `${reason || "dir"} ${event} event`);
          }
        });
        watchCtx.dirWatchers[dir] = watcher;
        dlog(`Added watcher for the "${dir}" dir`);
      }
    }
  }

  /**
   * @param {string} projectPath
   */
  function watchProject(projectPath) {
    /**
     * @type {WatchCtx}
     */
    const watchCtx = {
      projectPath,
      dirWatchers: {},
      isBsConfigDirty: false,
      rebuildTimeout: undefined,
      genTypeFileExtension: ".gen.tsx",
      isRebuildPending: false,
      isReRebuildNeeded: false,
    };

    const bsConfigPath = path.join(projectPath, "bsconfig.json");

    const genTypeConfig = require(bsConfigPath).gentypeconfig;
    if (genTypeConfig && genTypeConfig.generatedFileExtension) {
      // If the project uses gentype with a custom file extension
      // via generatedFileExtension, ignore them in watch mode
      watchCtx.genTypeFileExtension = genTypeConfig.generatedFileExtension;
    }

    syncDirsWatchers(watchCtx);
    fs.watch(bsConfigPath, event => {
      watchCtx.isBsConfigDirty = true;
      planRebuild(watchCtx, `bsconfig.json ${event} event`);
    });
  }

  /**
   * @param {boolean} withWebSocket
   */
  function prepareWatchMode(withWebSocket) {
    if (withWebSocket) {
      setUpWebSocket();
    }
    // for column one based error message

    process.stdin.on("close", exitProcess);
    // close when stdin stops
    if (os.platform() !== "win32") {
      process.stdin.on("end", exitProcess);
      process.stdin.resume();
    }
  }

  logStartCompiling();
  delegateCommand(delegatedArgs, () => {
    LAST_SUCCESS_BUILD_STAMP = Date.now();
    logFinishCompiling(0);
    prepareWatchMode(withWebSocket);
    notifyClients();
    watchProject(cwd);
  });
} else {
  switch (maybeSubcommand) {
    case "info":
    case "clean": {
      delegateCommand(process_argv.slice(2));
      break;
    }
    case undefined:
    case "build": {
      logStartCompiling();
      delegateCommand(process_argv.slice(2), logFinishCompiling);
      break;
    }
    case "format":
      require("./scripts/rescript_format.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "dump":
      require("./scripts/rescript_dump.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "dump":
      require("./scripts/rescript_dump.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "convert":
      require("./scripts/rescript_convert.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "-h":
    case "-help":
    case "help":
      help();
      break;
    case "-v":
    case "-version":
      console.log(require("./package.json").version);
      break;
    default:
      console.error(`Unknown subcommand or flags: ${maybeSubcommand}`);
      help();
      process.exit(2);
  }
}
