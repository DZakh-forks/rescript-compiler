#!/usr/bin/env node
//@ts-check
"use strict";

/* This script is supposed to be running in project root directory
 * It matters since we need read .sourcedirs(location)
 * and its content are file/directories with regard to project root
 */

var child_process = require("child_process");
var os = require("os");
var path = require("path");
var fs = require("fs");
var bsc_exe = require("./scripts/bin_path").bsc_exe;
var rescript_exe = require("./scripts/bin_path").rescript_exe;
var bsconfig = "bsconfig.json";

var LAST_BUILD_START = 0;
var LAST_FIRED_EVENT = 0;
/**
 * @type {[string,string][]}
 */
var reasonsToRebuild = [["proj", "started"]];

var LAST_SUCCESS_BUILD_STAMP = 0;
var cwd = process.cwd();
var lockFileName = path.join(cwd, ".bsb.lock");
process.env.BSB_PROJECT_ROOT = cwd;

var error_is_tty = process.stderr.isTTY;
var std_is_tty = process.stdout.isTTY;

// If the project uses gentype and uses custom file extension
// via generatedFileExtension, ignore them in watch mode
var bsConfigFile = path.join(cwd, bsconfig);
var genTypeFileExtension = ".gen.tsx";
if (fs.existsSync(bsConfigFile)) {
  var genTypeConfig = require(bsConfigFile).gentypeconfig;
  if (genTypeConfig) {
    genTypeFileExtension = genTypeConfig.generatedFileExtension;
  }
}

// All clients of type MiniWebSocket
/**
 * @type {any[]}
 */
var wsClients = [];
var isWatchMode = false;
var verbose = false;
/**
 * @type {string | undefined}
 */
var postBuild = undefined;
var withWebSocket = false;
var webSocketHost = "localhost";
var webSocketPort = 9999;

/**
 * @time{[number,number]}
 */
var startTime;
function updateStartTime() {
  startTime = process.hrtime();
  return "";
}
function updateFinishTime() {
  var diff = process.hrtime(startTime);
  return diff[0] * 1e9 + diff[1];
}

/**
 *
 * @param {string} file
 * @returns
 */
function getWatchFiles(file) {
  if (fs.existsSync(file)) {
    return JSON.parse(fs.readFileSync(file, "utf8"));
  } else {
    return { dirs: [], generated: [] };
  }
}

/**
 *
 * @param {*} str
 */
function dlog(str) {
  if (verbose) {
    console.log(str);
  }
}

function notifyClients() {
  wsClients = wsClients.filter(x => !x.closed && !x.socket.destroyed);
  var wsClientsLen = wsClients.length;
  dlog(`Alive sockets number: ${wsClientsLen}`);
  var data = '{"LAST_SUCCESS_BUILD_STAMP":' + LAST_SUCCESS_BUILD_STAMP + "}";
  for (var i = 0; i < wsClientsLen; ++i) {
    // in reverse order, the last pushed get notified earlier
    var client = wsClients[wsClientsLen - i - 1];
    if (!client.closed) {
      client.sendText(data);
    }
  }
}

function setUpWebSocket() {
  var WebSocket = require("./lib/minisocket.js").MiniWebSocket;
  var id = setInterval(notifyClients, 3000);
  require("http")
    .createServer()
    .on("upgrade", function (req, socket, upgradeHead) {
      dlog("connection opened");
      var ws = new WebSocket(req, socket, upgradeHead);
      socket.on("error", function (err) {
        dlog(`Socket Error ${err}`);
      });
      wsClients.push(ws);
    })
    .on("error", function (err) {
      // @ts-ignore
      if (err !== undefined && err.code === "EADDRINUSE") {
        var error = std_is_tty ? `\x1b[1;31mERROR:\x1b[0m` : `ERROR:`;
        console.error(`${error} The websocket port number ${webSocketPort} is in use.
Please pick a different one using the \`-ws [host:]port\` flag from bsb.`);
      } else {
        console.error(err);
      }
      process.exit(2);
    })
    .listen(webSocketPort, webSocketHost);
}

/**
 * @type {string[]}
 */
var delegatedArgs = [];
var process_argv = process.argv;

if (process.env.NINJA_ANSI_FORCED === undefined) {
  if (require("tty").isatty(1)) {
    process.env.NINJA_ANSI_FORCED = "1";
  }
} else {
  dlog(`NINJA_ANSI_FORCED: "${process.env.NINJA_ANSI_FORCED}"`);
}
function help() {
  console.log(`Usage: rescript <options> <subcommand>

\`rescript\` is equivalent to \`rescript build\`

Options:
  -v, -version  display version number
  -h, -help     display help

Subcommands:
  build
  clean
  format
  convert
  dump
  help

Run \`rescript <subcommand> -h\` for subcommand help. Examples:
  rescript build -h
  rescript format -h
The default \`rescript\` is equivalent to \`rescript build\` subcommand  
`);
}

var isBuilding = false;
function releaseBuild() {
  if (isBuilding) {
    try {
      fs.unlinkSync(lockFileName);
    } catch (err) {}
    isBuilding = false;
  }
}

// We use [~perm:0o664] rather than our usual default perms, [0o666], because
// lock files shouldn't rely on the umask to disallow tampering by other.
function acquireBuild() {
  if (isBuilding) {
    return false;
  } else {
    try {
      const fid = fs.openSync(lockFileName, "wx", 0o664);
      fs.closeSync(fid);
      isBuilding = true;
    } catch (err) {
      if (err.code === "EEXIST") {
        console.warn(lockFileName, "already exists, try later");
      } else console.log(err);
    }
    return isBuilding;
  }
}

function onUncaughtException(err) {
  console.error("Uncaught Exception", err);
  releaseBuild();
  process.exit(1);
}
function exitProcess() {
  releaseBuild();
  process.exit(0);
}

process.on("uncaughtException", onUncaughtException);

// OS signal handlers
// Ctrl+C
process.on("SIGINT", exitProcess);
// kill pid
process.on("SIGUSR1", exitProcess);
process.on("SIGUSR2", exitProcess);
process.on("SIGTERM", exitProcess);
process.on("SIGHUP", exitProcess);

var maybeSubcommand = process_argv[2];
if (
  maybeSubcommand !== undefined &&
  maybeSubcommand !== "build" &&
  maybeSubcommand !== "clean" &&
  maybeSubcommand !== "info"
  // delegate to native
) {
  switch (maybeSubcommand) {
    case "format":
      require("./scripts/rescript_format.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "dump":
      require("./scripts/rescript_dump.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "dump":
      require("./scripts/rescript_dump.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "convert":
      // Todo
      require("./scripts/rescript_convert.js").main(
        process.argv.slice(3),
        rescript_exe,
        bsc_exe
      );
      break;
    case "-h":
    case "-help":
    case "help":
      help();
      break;
    case "-v":
    case "-version":
      console.log(require("./package.json").version);
      break;
    default:
      console.error(`Unknown subcommand or flags: ${maybeSubcommand}`);
      help();
      process.exit(2);
  }
} else {
  var delegatedArgs = process_argv.slice(2);
  var isWatchMode = delegatedArgs.includes("-w");
  var wsParamIndex = delegatedArgs.indexOf("-ws");
  if (wsParamIndex > -1) {
    var hostAndPortNumber = (delegatedArgs[wsParamIndex + 1] || "").split(":");
    /**
     * @type {number}
     */
    var portNumber;
    if (hostAndPortNumber.length === 1) {
      portNumber = parseInt(hostAndPortNumber[0]);
    } else {
      webSocketHost = hostAndPortNumber[0];
      portNumber = parseInt(hostAndPortNumber[1]);
    }
    if (!isNaN(portNumber)) {
      webSocketPort = portNumber;
    }
    withWebSocket = true;
    dlog(`WebSocket host & port number: ${webSocketHost}:${webSocketPort}`);
  }

  verbose = delegatedArgs.includes("-verbose");
  /**
   * @type {child_process.ChildProcess}
   */
  var p;
  if (acquireBuild()) {
    try {
      p = child_process.spawn(rescript_exe, delegatedArgs, {
        stdio: "inherit",
      });
      LAST_BUILD_START = Date.now();
    } catch (e) {
      if (e.code === "ENOENT") {
        // when bsb is actually not found
        console.error(String(e));
      }
      releaseBuild();
      process.exit(2);
    }
    // The 'close' event will always emit after 'exit' was already emitted, or
    // 'error' if the child failed to spawn.
    p.on("close", code => {
      releaseBuild();
      if (code !== 0) {
        process.exit(code);
      } else if (isWatchMode) {
        startWatchMode(withWebSocket);
      }
    });
  } else {
    console.warn(`Another build detected or stale lockfile ${lockFileName}`);
    // racing magic code
    process.exit(133);
  }
  /**
   *
   * @param {boolean} withWebSocket
   */
  function startWatchMode(withWebSocket) {
    if (withWebSocket) {
      setUpWebSocket();
    }
    // for column one based error message

    /**
     * watchers are held so that we close it later
     */
    var watchers = [];

    process.stdin.on("close", exitProcess);
    // close when stdin stops
    if (os.platform() !== "win32") {
      process.stdin.on("end", exitProcess);
      process.stdin.resume();
    }

    var sourcedirs = path.join("lib", "bs", ".sourcedirs.json");
    var watchGenerated = [];

    function watchBuild(watchConfig) {
      var watchFiles = watchConfig.dirs;
      watchGenerated = watchConfig.generated;
      // close and remove all unused watchers
      watchers = watchers.filter(function (watcher) {
        if (watcher.dir === bsconfig) {
          return true;
        } else if (watchFiles.indexOf(watcher.dir) < 0) {
          dlog(`${watcher.dir} is no longer watched`);
          watcher.watcher.close();
          return false;
        } else {
          return true;
        }
      });

      // adding new watchers
      for (var i = 0; i < watchFiles.length; ++i) {
        var dir = watchFiles[i];
        if (
          !watchers.find(function (watcher) {
            return watcher.dir === dir;
          })
        ) {
          dlog(`watching dir ${dir} now`);
          var watcher = fs.watch(dir, onChange);
          watchers.push({ dir: dir, watcher: watcher });
        } else {
          // console.log(dir, 'already watched')
        }
      }
    }

    /**
     * @param {string | null} fileName
     */
    function checkIsRebuildReason(fileName) {
      // Return true if filename is nil, filename is only provided on Linux, macOS, Windows, and AIX.
      // On other systems, we just have to assume that any change is valid.
      // This could cause problems if source builds (generating js files in the same directory) are supported.
      if (!fileName) return true;

      return !(
        fileName === ".merlin" ||
        fileName.endsWith(".js") ||
        fileName.endsWith(".mjs") ||
        fileName.endsWith(".cjs") ||
        fileName.endsWith(genTypeFileExtension) ||
        watchGenerated.indexOf(fileName) >= 0 ||
        fileName.endsWith(".swp")
      );
    }

    /**
     * @return {boolean}
     */
    function needRebuild() {
      return reasonsToRebuild.length !== 0;
    }

    function logFinish(code) {
      let log = `>>>> Finish compiling`;
      if (code !== 0) {
        log = log + " (exit: " + code + ")";
      }
      if (std_is_tty) {
        log = "\x1b[36m" + log + "\x1b[0m";
      }
      if (code !== 0) {
        console.log(log);
      } else {
        console.log(log, Math.floor(updateFinishTime() / 1e6), "mseconds");
      }
    }

    function logStart() {
      updateStartTime();
      let log = `>>>> Start compiling`;
      if (std_is_tty) {
        log = "\x1b[36m" + log + "\x1b[0m";
      }
      console.log(log);
    }

    /**
     *
     * @param code {number}
     * @param signal {string}
     */
    function buildFinishedCallback(code, signal) {
      if (code === 0) {
        LAST_SUCCESS_BUILD_STAMP = Date.now();
        notifyClients();
        if (postBuild) {
          dlog(`running postbuild command: ${postBuild}`);
          child_process.exec(postBuild);
        }
      }
      logFinish(code);
      releaseBuild();
      if (needRebuild()) {
        build(0);
      } else {
        var files = getWatchFiles(sourcedirs);
        watchBuild(files);
      }
    }

    /**
     * TODO: how to make it captured by vscode
     * @param error {string}
     * @param highlight {string}
     */
    function outputError(error, highlight) {
      if (error_is_tty && highlight) {
        process.stderr.write(
          error.replace(highlight, "\x1b[1;31m" + highlight + "\x1b[0m")
        );
      } else {
        process.stderr.write(error);
      }
    }
    // Note this function filters the error output
    // it relies on the fact that ninja will merege stdout and stderr
    // of the compiler output, if it does not
    // then we should have a way to not filter the compiler output
    /**
     *
     * @param {number} depth
     * @returns
     */
    function build(depth) {
      if (reasonsToRebuild.length === 0) {
        dlog("No need to rebuild");
        return;
      } else {
        dlog(`Rebuilding since ${reasonsToRebuild}`);
      }
      if (acquireBuild()) {
        logStart();
        child_process
          .spawn(rescript_exe, [], {
            stdio: ["inherit", "inherit", "pipe"],
          })
          // @ts-ignore
          .on("data", function (s) {
            outputError(s, "ninja: error");
          })
          .on("exit", buildFinishedCallback)
          .stderr.setEncoding("utf8");
        // This is important to clean up all
        // previous queued events
        reasonsToRebuild = [];
        LAST_BUILD_START = Date.now();
      }
      // if acquiring lock failed, no need retry here
      // since buildFinishedCallback will try again
      // however this is no longer the case for multiple-process
      // it could fail due to other issues like .bsb.lock
      else {
        dlog(
          `Acquire lock failed, do the build later ${depth} : ${reasonsToRebuild}`
        );
        var waitTime = Math.pow(2, depth) * 40;
        setTimeout(function () {
          var d = Math.min(depth + 1, 5);
          build(d);
        }, waitTime);
      }
    }
    /**
     *
     * @param {fs.WatchEventType} event
     * @param {string | null} reason
     */
    function onChange(event, reason) {
      var eventTime = Date.now();
      var timeDiff = eventTime - LAST_BUILD_START;
      var eventDiff = eventTime - LAST_FIRED_EVENT;
      dlog(`Since last build : ${timeDiff} -- ${eventDiff}`);
      if (timeDiff < 5 || eventDiff < 5) {
        // for 5ms, we could think that the ninja not get
        // kicked yet, so there is really no need
        // to send more events here

        // note reasonsToRebuild also
        // helps avoid redundant build, but this will
        // save the event loop call `setImmediate`
        return;
      }
      if (checkIsRebuildReason(reason)) {
        dlog(`\nEvent ${event} ${reason}`);
        LAST_FIRED_EVENT = eventTime;
        reasonsToRebuild.push([event, reason || ""]);
        // Some editors are using temporary files to store edits.
        // This results in two sync change events: change + rename and two sync builds.
        // Using setImmediate will ensure that only one build done.
        setImmediate(() => {
          if (needRebuild()) {
            if (process.env.BS_WATCH_CLEAR && console.clear) {
              console.clear();
            }
            build(0);
          }
        });
      }
    }

    watchers.push({ watcher: fs.watch(bsconfig, onChange), dir: bsconfig });
    build(0);
  }
}
